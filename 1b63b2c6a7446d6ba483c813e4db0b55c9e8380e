{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8b620dcd_c142c457",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 800
      },
      "writtenOn": "2022-02-16T16:20:15Z",
      "side": 1,
      "message": "I\u0027ve added an updated way of executing wait-mcp, taking into account that it may be needed in other steps like the upgrade, and differentiating between two blocks: one in case dci_workarounds does not include the bz, another if it includes it. I\u0027ve designed it based on the tests I\u0027ve made for BigIP and SPK that worked in this job: https://www.distributed-ci.io/jobs/b8f61c4a-02f6-48ea-9cdb-cfe37b1d18d4/jobStates",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04b20557_3e1c4c80",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 800
      },
      "writtenOn": "2022-02-17T16:27:56Z",
      "side": 1,
      "message": "\u003e Patch Set 4:\n\u003e \n\u003e FAILURE https://www.distributed-ci.io/jobs/adf95a7c-a832-48e9-b8ee-7bed9278ff34/jobStates from https://github.com/dci-labs/dallas-pipelines/pull/241\n\nDon\u0027t have this in mind, it was for testing another stuff.",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f78d9c22_45e53678",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 724
      },
      "writtenOn": "2022-02-17T16:39:49Z",
      "side": 1,
      "message": "Ram√≥n, thanks for addressing this. Having a defined approach for workarounds linked to rescue a block is good.",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa61a492_a8f27585",
        "filename": "roles/common/tasks/wait-mcp.yml",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 938
      },
      "writtenOn": "2022-02-16T16:48:48Z",
      "side": 1,
      "message": "Hi @Ramon, I feel like we go the way more complex than it was intended. We probably could simply wrap the rescue in BZ: https://github.com/redhat-cip/dci-openshift-agent/blob/master/roles/common/tasks/wait-mcp.yml#L23-L67",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71e571b4_f56d76b0",
        "filename": "roles/common/tasks/wait-mcp.yml",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 800
      },
      "writtenOn": "2022-02-16T17:04:27Z",
      "side": 1,
      "message": "Bad thing is that the rescue below is attached to the block, so we cannot, let\u0027s say, put the \"when\" condition to only the rescue, because it will also apply for the block that uses that rescue. That\u0027s why I\u0027ve done this in this way, also to easily remove the workaround when fixing the BZ.",
      "parentUuid": "aa61a492_a8f27585",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26eedaee_e54d8e09",
        "filename": "roles/common/tasks/wait-mcp.yml",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 724
      },
      "writtenOn": "2022-02-17T02:52:27Z",
      "side": 1,
      "message": "Hello!\n\nYeah, I thinking also what Tatiana mentioned, adding a block on the rescue with a when condition. So that rescue code is executed on error and if the BZ is active. I did a small test for this: \n\n---\n- name: test\n  hosts: localhost\n  vars:\n    bz_active: false\n  tasks:\n    - name: \"The code that can fail\"\n      block:\n        - name: \"Get minor OCP minor\"\n          set_fact:\n            ocp_minor: \"{{ ocp_version.split(\u0027.\u0027)[3] }}\"  \n      rescue:\n        - name: \"workaround\"\n          block: \n            - name: \"Workaround step1\"\n              debug:\n                msg: \"workaround step 1\"\n\n            - name: \"Workaround step2\"\n              debug:\n                msg: \"workaround step 2\"\n          when: bz_active is true\n...\n\nCheers",
      "parentUuid": "71e571b4_f56d76b0",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "666d756e_aeb6f5e2",
        "filename": "roles/common/tasks/wait-mcp.yml",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 800
      },
      "writtenOn": "2022-02-17T08:17:01Z",
      "side": 1,
      "message": "Thanks Beto for the feedback! However, I don\u0027t think it is a good solution, from my point of view. As I said, a rescue block is meant to be executed when a specific task from a block failed; so, if the rescue block passed, then the captured failure is \"rescued\", let\u0027s say.\n\nSo, imagine we extend your test with this (I\u0027ve changed the when statement because it was not working in my ansible exec, but it is the same):\n\n```\n- name: test\n  hosts: localhost\n  vars:\n    bz_active: false\n  tasks:\n    - name: \"The code that can fail\"\n      block:\n        - name: \"Get minor OCP minor\"\n          set_fact:\n            ocp_minor: \"{{ ocp_version.split(\u0027.\u0027)[3] }}\"  \n      rescue:\n        - name: \"workaround\"\n          block: \n            - name: \"Workaround step1\"\n              debug:\n                msg: \"workaround step 1\"\n            - name: \"Workaround step2\"\n              debug:\n                msg: \"workaround step 2\"\n          when: bz_active|bool\n\n    - name: \"Task that should not be executed if bz_active is false but it is\"\n      debug:\n        msg: \"Continue\"\n```\n\nFirstly, the task on the block will fail. Then, rescue is called, correct. If bz_active is not true, the block within the rescue will not be called, correct. BUT, as rescue has not failed, the previous, failed task can be considered as \"rescued\" and the execution will continue, so that the last task will be executed. This would not be true in case the workaroud is not applied, because if the very first task failed, then the job has to fail, not to pass.\n\nSo, that\u0027s why I would leave this in the current status. What do you think?",
      "parentUuid": "26eedaee_e54d8e09",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d64a81d8_e7a902a6",
        "filename": "roles/common/tasks/wait-mcp.yml",
        "patchSetId": 4
      },
      "lineNbr": 21,
      "author": {
        "id": 724
      },
      "writtenOn": "2022-02-17T16:39:49Z",
      "side": 1,
      "message": "I believe it could be possible to re-raise the error from the previous tasks: https://stackoverflow.com/questions/59031422/ansible-blocks-re-raising-errors-in-rescue-block but I am not against your current approach. LGTM, thanks!",
      "parentUuid": "666d756e_aeb6f5e2",
      "revId": "1b63b2c6a7446d6ba483c813e4db0b55c9e8380e",
      "serverId": "6c1dc8ef-8b94-40e4-bd83-c2359d45ecc0"
    }
  ]
}